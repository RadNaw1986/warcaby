{"ast":null,"code":"'use strict';\n\nconst PLUGIN_NAME = 'sha256_password';\nconst crypto = require('crypto');\nconst {\n  xorRotating\n} = require('../auth_41');\nconst REQUEST_SERVER_KEY_PACKET = Buffer.from([1]);\nconst STATE_INITIAL = 0;\nconst STATE_WAIT_SERVER_KEY = 1;\nconst STATE_FINAL = -1;\nfunction encrypt(password, scramble, key) {\n  const stage1 = xorRotating(Buffer.from(`${password}\\0`, 'utf8'), scramble);\n  return crypto.publicEncrypt(key, stage1);\n}\nmodule.exports = function () {\n  let pluginOptions = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  return _ref => {\n    let {\n      connection\n    } = _ref;\n    let state = 0;\n    let scramble = null;\n    const password = connection.config.password;\n    const authWithKey = serverKey => {\n      const _password = encrypt(password, scramble, serverKey);\n      state = STATE_FINAL;\n      return _password;\n    };\n    return data => {\n      switch (state) {\n        case STATE_INITIAL:\n          scramble = data.slice(0, 20);\n          // if client provides key we can save one extra roundrip on first connection\n          if (pluginOptions.serverPublicKey) {\n            return authWithKey(pluginOptions.serverPublicKey);\n          }\n          state = STATE_WAIT_SERVER_KEY;\n          return REQUEST_SERVER_KEY_PACKET;\n        case STATE_WAIT_SERVER_KEY:\n          if (pluginOptions.onServerPublicKey) {\n            pluginOptions.onServerPublicKey(data);\n          }\n          return authWithKey(data);\n        case STATE_FINAL:\n          throw new Error(`Unexpected data in AuthMoreData packet received by ${PLUGIN_NAME} plugin in STATE_FINAL state.`);\n      }\n      throw new Error(`Unexpected data in AuthMoreData packet received by ${PLUGIN_NAME} plugin in state ${state}`);\n    };\n  };\n};","map":{"version":3,"names":["PLUGIN_NAME","crypto","require","xorRotating","REQUEST_SERVER_KEY_PACKET","Buffer","from","STATE_INITIAL","STATE_WAIT_SERVER_KEY","STATE_FINAL","encrypt","password","scramble","key","stage1","publicEncrypt","module","exports","pluginOptions","arguments","length","undefined","_ref","connection","state","config","authWithKey","serverKey","_password","data","slice","serverPublicKey","onServerPublicKey","Error"],"sources":["G:/PROGRAMY/Node.js/warcaby/frontend/node_modules/mysql2/lib/auth_plugins/sha256_password.js"],"sourcesContent":["'use strict';\n\nconst PLUGIN_NAME = 'sha256_password';\nconst crypto = require('crypto');\nconst { xorRotating } = require('../auth_41');\n\nconst REQUEST_SERVER_KEY_PACKET = Buffer.from([1]);\n\nconst STATE_INITIAL = 0;\nconst STATE_WAIT_SERVER_KEY = 1;\nconst STATE_FINAL = -1;\n\nfunction encrypt(password, scramble, key) {\n  const stage1 = xorRotating(\n    Buffer.from(`${password}\\0`, 'utf8'),\n    scramble\n  );\n  return crypto.publicEncrypt(key, stage1);\n}\n\nmodule.exports = (pluginOptions = {}) => ({ connection }) => {\n  let state = 0;\n  let scramble = null;\n\n  const password = connection.config.password;\n\n  const authWithKey = serverKey => {\n    const _password = encrypt(password, scramble, serverKey);\n    state = STATE_FINAL;\n    return _password;\n  };\n\n  return data => {\n    switch (state) {\n      case STATE_INITIAL:\n        scramble = data.slice(0, 20);\n        // if client provides key we can save one extra roundrip on first connection\n        if (pluginOptions.serverPublicKey) {\n          return authWithKey(pluginOptions.serverPublicKey);\n        }\n\n        state = STATE_WAIT_SERVER_KEY;\n        return REQUEST_SERVER_KEY_PACKET;\n\n      case STATE_WAIT_SERVER_KEY:\n        if (pluginOptions.onServerPublicKey) {\n          pluginOptions.onServerPublicKey(data);\n        }\n        return authWithKey(data);\n      case STATE_FINAL:\n        throw new Error(\n          `Unexpected data in AuthMoreData packet received by ${PLUGIN_NAME} plugin in STATE_FINAL state.`\n        );\n    }\n\n    throw new Error(\n      `Unexpected data in AuthMoreData packet received by ${PLUGIN_NAME} plugin in state ${state}`\n    );\n  };\n};\n"],"mappings":"AAAA,YAAY;;AAEZ,MAAMA,WAAW,GAAG,iBAAiB;AACrC,MAAMC,MAAM,GAAGC,OAAO,CAAC,QAAQ,CAAC;AAChC,MAAM;EAAEC;AAAY,CAAC,GAAGD,OAAO,CAAC,YAAY,CAAC;AAE7C,MAAME,yBAAyB,GAAGC,MAAM,CAACC,IAAI,CAAC,CAAC,CAAC,CAAC,CAAC;AAElD,MAAMC,aAAa,GAAG,CAAC;AACvB,MAAMC,qBAAqB,GAAG,CAAC;AAC/B,MAAMC,WAAW,GAAG,CAAC,CAAC;AAEtB,SAASC,OAAOA,CAACC,QAAQ,EAAEC,QAAQ,EAAEC,GAAG,EAAE;EACxC,MAAMC,MAAM,GAAGX,WAAW,CACxBE,MAAM,CAACC,IAAI,CAAE,GAAEK,QAAS,IAAG,EAAE,MAAM,CAAC,EACpCC,QACF,CAAC;EACD,OAAOX,MAAM,CAACc,aAAa,CAACF,GAAG,EAAEC,MAAM,CAAC;AAC1C;AAEAE,MAAM,CAACC,OAAO,GAAG;EAAA,IAACC,aAAa,GAAAC,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAG,CAAC,CAAC;EAAA,OAAKG,IAAA,IAAoB;IAAA,IAAnB;MAAEC;IAAW,CAAC,GAAAD,IAAA;IACtD,IAAIE,KAAK,GAAG,CAAC;IACb,IAAIZ,QAAQ,GAAG,IAAI;IAEnB,MAAMD,QAAQ,GAAGY,UAAU,CAACE,MAAM,CAACd,QAAQ;IAE3C,MAAMe,WAAW,GAAGC,SAAS,IAAI;MAC/B,MAAMC,SAAS,GAAGlB,OAAO,CAACC,QAAQ,EAAEC,QAAQ,EAAEe,SAAS,CAAC;MACxDH,KAAK,GAAGf,WAAW;MACnB,OAAOmB,SAAS;IAClB,CAAC;IAED,OAAOC,IAAI,IAAI;MACb,QAAQL,KAAK;QACX,KAAKjB,aAAa;UAChBK,QAAQ,GAAGiB,IAAI,CAACC,KAAK,CAAC,CAAC,EAAE,EAAE,CAAC;UAC5B;UACA,IAAIZ,aAAa,CAACa,eAAe,EAAE;YACjC,OAAOL,WAAW,CAACR,aAAa,CAACa,eAAe,CAAC;UACnD;UAEAP,KAAK,GAAGhB,qBAAqB;UAC7B,OAAOJ,yBAAyB;QAElC,KAAKI,qBAAqB;UACxB,IAAIU,aAAa,CAACc,iBAAiB,EAAE;YACnCd,aAAa,CAACc,iBAAiB,CAACH,IAAI,CAAC;UACvC;UACA,OAAOH,WAAW,CAACG,IAAI,CAAC;QAC1B,KAAKpB,WAAW;UACd,MAAM,IAAIwB,KAAK,CACZ,sDAAqDjC,WAAY,+BACpE,CAAC;MACL;MAEA,MAAM,IAAIiC,KAAK,CACZ,sDAAqDjC,WAAY,oBAAmBwB,KAAM,EAC7F,CAAC;IACH,CAAC;EACH,CAAC;AAAA"},"metadata":{},"sourceType":"script","externalDependencies":[]}